前面介绍了springBoot启动任务，启动任务的特点是只在项目启动时进行，以后都不再执行。但是实际业务上可能还有些需求要求某些任务在程序运行期间按照指定的时间周期执行。这就需要用到springBoot定时任务。

在定时任务中一般有两种情况：
>1：指定在某个固定时间执行任务，只执行一次后续不再执行；
>2：指定每隔一段时间周而复始的执行。



#### Scheduled定时任务
在springBoot中使用Scheduled定时任务比较简单，下面进行介绍。
###### 1、启动类添加注解@EnableScheduling
首先需要在启动类添加注解@EnableScheduling，开启定时任务功能，默认是关闭的。
```java
@EnableScheduling
@SpringBootApplication
public class ExampleSchedulerApplication {

    public static void main(String[] args) {
        SpringApplication.run(ExampleSchedulerApplication.class, args);
        System.out.println("---------------- 启动成功!! --------------");
    }
}
```

###### 2、编写定时任务类
新建scheduled包，在scheduled包下创建MyScheduledJobs类，这个类中就写业务需要定时要执行的方法。需将此类标记为Spring容器中的一个Bean如业务类添加注解@Service。

编写定时方法，方法上需要添加注解@Scheduled启动项目即可。
```java
@Component
public class MyScheduledJobs {

    @Scheduled(fixedDelay = 3000)
    public void sayHelloFixedRate() throws InterruptedException {
        SimpleDateFormat simpleDateFormat=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");
        Thread.sleep(2000);
        String now=simpleDateFormat.format(new Date());
        System.out.println(now + "  hello fixedDelay");
    }
}
```
![ab819717c638a0cfbad893bf55a50b98.png](evernotecid://856601FE-F606-47C9-A312-C117E55C924E/appyinxiangcom/17968037/ENResource/p1167)



在springBoot中使用Scheduled定时任务关键的是@Scheduled这个注解，下面将介绍这个注解的几个重要属性。

#### @Scheduled属性
@Schedule注解有几个比较重要的属性，fixedRate和fixedDelay是其中两个比较容易混淆的属性。

`fixedDelay:`非常好理解，它的间隔时间是根据上次的任务结束的时候开始计时的。比如一个方法上设置了fixedDelay=3s，方法执行耗时2s,假如该方法第一次开始执行的时刻为00:00:00， 执行完该方法时刻为00:00:02s，从此刻开始计时，经过fixedDelay=3s也就是00:00:05s开始第二次执行该方法。两次之间的执行时间间隔为 ixedDelay + 方法耗时 = 5s。下面的示例也验证了这一点、
![ab819717c638a0cfbad893bf55a50b98.png](evernotecid://856601FE-F606-47C9-A312-C117E55C924E/appyinxiangcom/17968037/ENResource/p1167)

`fixedRate:`它的间隔时间是从上次任务的开始时间开始计时，不会理会任务本身执行的时间。
![6a51265d2d6d5a4bf33d34af205d516e.png](evernotecid://856601FE-F606-47C9-A312-C117E55C924E/appyinxiangcom/17968037/ENResource/p1168)

`initialDelay:`首次任务启动的延迟时间
`cron:`@Schedule注解还支持cron表达式，下面将详细介绍。
#### Cron 表达式

Cron表达式是一个字符串，字符串以5或6个空格隔开，分为6或7个域，每一个域代表一个含义，Cron语法格式如下，其中"年"这个域可以省略,需要注意的是在spring自带的定时任务中正确的cron表达式只能是6个域，否则会抛出IllegalArgumentException提示：
```
秒 分 时 日 月 周 [年]
```
每一个域都使用数字，但还可以出现特殊的通配字符，每一个域的含义以及每一个域可出现的通配符字符如下：
![5771b0c13f9f747f94a07255a79c0b71.png](evernotecid://856601FE-F606-47C9-A312-C117E55C924E/appyinxiangcom/17968037/ENResource/p1245)


需要说明的是，Cron 表达式中，“周” 是从周日开始计算的。“周” 域上的 1 表示的是周日，7 表示周六。

>`*`:匹配任意值，例如* * * * * ?表示每秒执行一次任务。

>`,`:用于指定多个取值，例如0 0 6,12 * * ?表示每天6点、12点执行任务。

>`-`:指定一个范围内的取值，例如0 0 9-17 * * MON-FRI表示周一至周五的9点到17点之间每小时执行一次任务。

>`/`:示起始时间开始触发，然后每隔固定时间触发一次，* 5/10 * * * ?表示每天的每个小时从第5分钟开始，每10分钟执行一次。

>`?`:表示不指定值。使用的场景为不需要关心当前设置这个字段的值。例如，要在每月的 8 号触发一个操作，但不关心是周几，我们可以这么设置 0 0 0 8 * ?。

>`L`:表示英文中的 LAST 的意思，只能在 “日” 和 “周” 中使用。在 “日” 中设置，表示当月的最后一天(依据当前月份，如果是二月还会依据是否是润年), 在 “周” 上表示周六，相当于 “7” 或“SAT”。如果在DayofWeek域使用5L,意味着在最后的一个星期四触发。

>`W`:表示有效工作日(周一到周五),只能出现在DayofMonth域，系统将在离指定日期的最近的有效工作日触发事件。例如：在 DayofMonth使用5W，如果5日是星期六，则将在最近的工作日：星期五，即4日触发。如果5日是星期天，则在6日(周一)触发；如果5日在星期一 到星期五中的一天，则就在5日触发。另外一点，W的最近寻找不会跨过月份。

举几个常用的例子:
```java
每隔5秒执行一次："*/5 * * * * ?"
每隔1分钟执行一次："0 */1 * * * ?"
每天23点执行一次："0 0 23 * * ?"
每天凌晨1点执行一次："0 0 1 * * ?"
每月1号凌晨1点执行一次："0 0 1 1 * ?"
每月最后一天23点执行一次："0 0 23 L * ?"
每周星期天凌晨1点实行一次："0 0 1 ? * L"
在26分、29分、33分执行一次："0 26,29,33 * * * ?"
每天的0点、13点、18点、21点都执行一次："0 0 0,13,18,21 * * ?"
表示在每月的1日的凌晨2点调度任务："0 0 2 1 * ? *"
表示周一到周五每天上午10：15执行作业："0 15 10 ? * MON-FRI"
表示2002-2006年的每个月的最后一个星期五上午10:15执行："0 15 10 ? 6L 2002-2006"
```


下面是通过cron表达式启动定时任务的一个示例，代码及运行结果如下：
```java
@Component
public class MyScheduledCronJobs {
    
    @Scheduled(cron = "*/5 * * * * ?")
    public void sayHelloFixedRate() throws InterruptedException {
        SimpleDateFormat simpleDateFormat=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");
        Thread.sleep(2000);
        String now=simpleDateFormat.format(new Date());
        System.out.println(now + "  hello cron--->" + Thread.currentThread().getName());
    }    //单位ms
}
```

![a086a8c0e046093be65889cad2ab4d91.png](evernotecid://856601FE-F606-47C9-A312-C117E55C924E/appyinxiangcom/17968037/ENResource/p1248)



#### Scheduled定时任务多线程异步执行
##### 配置定时任务异步执行
使用@Schedule的方式启动定时任务，默认是单线程同步执行的，如果同时启动了多个定时任务，一旦其中某个定时任务中途被阻塞,会导致其余的定时任务不会按照预设的时间执行。
![b836d8cc6e75120c3894020761ae0c31.png](evernotecid://856601FE-F606-47C9-A312-C117E55C924E/appyinxiangcom/17968037/ENResource/p1251)


为了解决这个问题，需要配置支持定时任务异步执行。很简单，在定时任务的方法上加上注解@Async即可：
![8d3697f1abfcea61baa643a93c935574.png](evernotecid://856601FE-F606-47C9-A312-C117E55C924E/appyinxiangcom/17968037/ENResource/p1253)


##### 自定义线程池执行任务
一个系统中，有些定时任务是比较重要的，有些则是不太重要的，一个合理的做法是将其分类分别放到不同的线程池中执行。实现很简单，
`
1、定义配置类，配置两个线程池
`
```java
@Configuration
@EnableAsync
public class ExecutorConfig {
    @Bean
    public Executor executor1() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setThreadNamePrefix("qin-schedule-");
        executor.setMaxPoolSize(20);
        executor.setCorePoolSize(15);
        executor.setQueueCapacity(0);
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        return executor;
    }

    @Bean
    public Executor executor2() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setThreadNamePrefix("zhang-schedule-");
        executor.setMaxPoolSize(20);
        executor.setCorePoolSize(15);
        executor.setQueueCapacity(0);
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        return executor;
    }
}
```

`
2、定时任务显示指定调用线程池
`
上面在配置类里面初始化了两个线程池，所以会有两个线程池分别叫executor1和executor1被生成放到容器中，@Async注解是可以指定使用哪个线程池的。这样就可以在不同的线程池中执行不同的定时任务了
```java
@Component
public class MyScheduledSleepJobs {

    //测试时取消注释
    @Async("executor1")
    @Scheduled(cron = "*/5 * * * * ?")
    public void sayHelloFixedRate() throws InterruptedException {
        SimpleDateFormat simpleDateFormat=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");
        String now=simpleDateFormat.format(new Date());
        System.out.println(now + "  hello cron1--->" + Thread.currentThread().getName());
        Thread.sleep(100000);
    }    //单位ms


    //测试时取消注释
    @Async("executor2")
    @Scheduled(cron = "*/5 * * * * ?")
    public void sayHelloFixedRateAnother() throws InterruptedException {
        SimpleDateFormat simpleDateFormat=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");
        Thread.sleep(2000);
        String now=simpleDateFormat.format(new Date());
        System.out.println(now + "  hello cron2--->" + Thread.currentThread().getName());
    }    //单位ms
}
```
![b10f7026ffbc643ce56e7903abd3e394.png](evernotecid://856601FE-F606-47C9-A312-C117E55C924E/appyinxiangcom/17968037/ENResource/p1254)





>本文示例环境：\
操作系统：macOs 12.1 \
JDK版本：12.0.1 \
maven版本: 3.8.4 \
springBoot版本：2.7.0




